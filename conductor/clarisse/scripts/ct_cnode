#!/usr/bin/env python

"""
Wrapper around cnode
"""
import os
import re
import sys
import argparse
import subprocess

NUMBER_RE = re.compile(r"^(\d+)$")
RANGE_RE = re.compile(r"^(?:(\d+):(\d+)(?:\%(\d+))?)+$")
BIG_NUMBER = 99999999


def get_bounding_frames(*fame_specs):
    """
    Get frames to cover the range being rendered.

    We do this because Clarisse doesn't render images unless they have their
    sequence attributes set, even if the command line flags specify what frames
    to render. Therefore we have to calculate the frames needed and turn them
    on.

    Raises:
        ValueError: Raises if the spec is malformed.

    Returns:
        tuple(int, int): bounding frames
    """
    min_frame = BIG_NUMBER
    max_frame = -BIG_NUMBER

    for spec in fame_specs:
        number_match = NUMBER_RE.match(spec)
        range_match = RANGE_RE.match(spec)

        if not (range_match or number_match):
            raise ValueError("Spec format must be 'start[:end[%step]]")
        if range_match:
            start, end, _ = [int(n or 1) for n in range_match.groups()]
        else:
            start = end = int(number_match.groups()[0])

        if start < min_frame:
            min_frame = start
        if end > max_frame:
            max_frame = end

    return min_frame, max_frame


def generate_prerender_script_arg(args):
    """
    Constructs pre render script with some useful information as args.
    
    Example: 
        /tmp/conductor/ct_prep.py -range 1 100 -images project://scene/imgHigh
        project://scene/imgLow

    Args:
        args (list): image and frame range arguments 
    
    Returns:
        string: script with args
    """

    script_directory = os.path.dirname(sys.argv[0])
    prep_script = os.path.join(script_directory, "ct_prep.py")
    min_frame, max_frame = get_bounding_frames(*args.image_frames_list)
    return "{} -range {:d} {:d} -images {}".format(
        prep_script, min_frame, max_frame, " ".join(args.image)
    )


def main():
    """
    Mainn function to run cnode with conductor adjustments.
    """
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-image_frames_list",
        nargs="*",
        type=str,
        required=True,
        help="List of image frame specs.",
    )
    parser.add_argument("-image", nargs="*", type=str, help="List of images.")

    args, pass_through_args = parser.parse_known_args()

    # We will change to the working directory because cnode cannot deal with
    # spaces in the project filepath. We have eliminated spaces from the project
    # filename. But the directory name is beyond our control, so we cd into it
    # and work from there. https://www.isotropix.com/user/bugtracker/363 .
    proj = pass_through_args[0]
    work_dir, basename = (os.path.dirname(proj), os.path.basename(proj))
    pass_through_args[0] = basename

    cnode_args = ["cnode"] + pass_through_args

    config_path = os.path.join(os.path.dirname(sys.argv[0]), "clarisse.cfg")

    # These args are generally args we've decided to put in the wrapper rather
    # than allow the user to specify them in the task command.
    cnode_args += [
        "-config_file",
        config_path,
        "-log_width",
        0,
        "-search_path",
        "./",
        "-stats",
        "-log_level",
        "Debug5",
        "-license_server",
        "conductor_ilise:40500",
    ]

    if args.image:
        cnode_args += ["-image"] + args.image
        cnode_args += ["-image_frames_list"] + args.image_frames_list

    cnode_args += ["-script"] + [generate_prerender_script_arg(args)]

    sys.stdout.write(
        "Running command:..\n{}\nfrom:\n{}\n".format(" ".join(cnode_args), work_dir)
    )

    os.chdir(work_dir)

    p = subprocess.Popen(cnode_args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

    for line in iter(p.stdout.readline, b""):
        sys.stdout.write(line)
        sys.stdout.flush()


main()
